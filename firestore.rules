rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    // Users collection and activeSession subcollection
    match /users/{userId} {
      // Owner can read/write own profile (but cannot set isAdmin field)
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Prevent non-admins from setting isAdmin flag
      allow update: if request.auth != null &&
        request.auth.uid == userId &&
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAdmin']) ||
         isAdmin());

      // Allow authenticated users to create their own user document (for first-time sign-up)
      // This is necessary for Google sign-in and other OAuth flows
      // Users cannot set isAdmin during signup
      allow create: if request.auth != null &&
        request.auth.uid == userId &&
        (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == false);

      // Allow any authenticated user to update follower/following counts
      // This is safe because only increment/decrement operations are used in the code
      allow update: if request.auth != null &&
        request.resource.data.keys().hasAny(['followersCount', 'followingCount', 'inboundFriendshipCount', 'outboundFriendshipCount', 'mutualFriendshipCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'username', 'name', 'bio', 'tagline', 'pronouns', 'location', 'website', 'socialLinks', 'profilePicture', 'totalHours', 'profileVisibility', 'activityVisibility', 'projectVisibility', 'createdAt']);

      // Allow any authenticated user to read basic user profiles
      // This is necessary for group features (members list, leaderboards, etc.)
      // Privacy settings apply to activity/projects, not basic profile info
      allow read: if request.auth != null;

      // Allow listing users for discovery when authenticated
      allow list: if request.auth != null;

      // Allow unauthenticated username availability checks (read-only, query by username)
      // This is safe because it only reveals if a username exists, not other profile data
      allow list: if request.query.where.field == 'username' &&
        request.query.where.op == '==' &&
        request.query.limit <= 1;

      // Active session subcollection - user can read/write their own active timer
      match /activeSession/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Activity preferences subcollection - user can read/write their own activity preferences
      match /activityPreferences/{typeId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // User activities
    match /activities/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read activities if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'followers' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'everyone' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // User activities subcollections (daily, weekly, etc.)
    match /activities/{userId}/{subcollection} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read activities if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'followers' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'everyone' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // User projects - using subcollection structure
    match /projects/{userId}/userProjects/{projectId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read projects if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'followers' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'everyone' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }

    // Sessions
    match /sessions/{sessionId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isSessionOwner() {
        return isAuthenticated() && resource.data.userId == request.auth.uid;
      }

      function isFollowing(userId) {
        return exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      }

      function canReadSession() {
        return isAuthenticated() && (
          // Owner can always read their own sessions
          isSessionOwner() ||
          // Public sessions can be read by anyone
          resource.data.visibility == 'everyone' ||
          // Followers can read 'followers' visibility sessions
          (resource.data.visibility == 'followers' && isFollowing(resource.data.userId)) ||
          // Fallback: allow if visibility field doesn't exist
          !('visibility' in resource.data)
        );
      }

      // Create: validate userId on the incoming document
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;

      // Get: allow individual reads based on visibility settings
      allow get: if canReadSession();

      // List: allow authenticated users to query sessions (results filtered by get rule)
      allow list: if isAuthenticated();

      // Update/Delete: only session owner
      allow update, delete: if isSessionOwner();

      // Allow authenticated users to update supportedBy array and commentCount for likes/comments
      // User can only add/remove their own ID from supportedBy array
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['supportedBy', 'supportCount', 'commentCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'projectId', 'title', 'description', 'duration', 'startTime', 'tags', 'visibility', 'createdAt']) &&
        (
          // Either supportedBy wasn't changed
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['supportedBy']) ||
          // Or the user is only adding/removing their own ID
          (
            // Check if user is adding their ID (not already in supportedBy)
            (request.resource.data.supportedBy.hasAll([request.auth.uid]) &&
             !resource.data.get('supportedBy', []).hasAll([request.auth.uid])) ||
            // Check if user is removing their ID (was in supportedBy)
            (!request.resource.data.supportedBy.hasAll([request.auth.uid]) &&
             resource.data.get('supportedBy', []).hasAll([request.auth.uid]))
          )
        );
    }
    
    // Comments
    match /comments/{commentId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      // Create: validate userId on the incoming document
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;

      // Read/list: allow any authenticated user to fetch comments (per-document rules apply)
      allow get: if isAuthenticated();
      allow list: if isAuthenticated();

      // Update: only comment owner can modify their own comment
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // Allow authenticated users to update replyCount and likeCount when managing replies/likes
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['replyCount', 'likeCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'sessionId', 'content', 'parentId', 'createdAt']);

      // Delete: only comment owner can delete their own comment
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Comment likes
    match /commentLikes/{likeId} {
      // Allow reading individual likes if user is involved
      allow get: if request.auth != null &&
        (request.auth.uid == likeId.split('_')[0] || request.auth.uid == likeId.split('_')[1]);

      // Allow listing likes for queries filtered by userId
      allow list: if request.auth != null &&
        request.auth.uid == resource.data.userId;

      // Allow creating own likes
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // Allow deleting own likes
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }
    
    // Notifications
    match /notifications/{notificationId} {
      // Create: validate userId on the incoming document (for system-created notifications)
      allow create: if request.auth != null;
      // Read/Update/Delete: only notification owner can access
      allow read, update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Follows
    match /follows/{followId} {
      // Create: validate followerId matches authenticated user and both users exist
      allow create: if request.auth != null && 
        request.resource.data.followerId == request.auth.uid &&
        request.resource.data.followingId != request.auth.uid &&
        exists(/databases/$(database)/documents/users/$(request.resource.data.followingId));
      
      // Read: allow authenticated users to read follows for stats calculation
      allow read: if request.auth != null;
      
      // Delete: only the follower can delete their own follow
      allow delete: if request.auth != null && resource.data.followerId == request.auth.uid;
    }
    
    // Groups
    match /groups/{groupId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isDiscoverablePrivacy(setting) {
        return setting == 'public' || setting == 'approval-required';
      }

      function isDiscoverableGroup() {
        return ('privacySetting' in resource.data &&
          isDiscoverablePrivacy(resource.data.privacySetting)) ||
          !('privacySetting' in resource.data);
      }

      function isGroupMember() {
        return isAuthenticated() &&
          ('memberIds' in resource.data) &&
          resource.data.memberIds.hasAny([request.auth.uid]);
      }

      function isGroupAdmin() {
        return isAuthenticated() &&
          ('adminUserIds' in resource.data) &&
          resource.data.adminUserIds.hasAny([request.auth.uid]);
      }

      function isGroupCreator() {
        return isAuthenticated() &&
          resource.data.createdByUserId == request.auth.uid;
      }

      // Allow reading individual groups for public or approval-required access, or members
      allow get: if isDiscoverableGroup() || isGroupMember();

      // Allow listing groups for authenticated discovery experiences
      allow list: if isAuthenticated();

      // Allow group creators and admins to update group
      allow update: if isGroupCreator() || isGroupAdmin();

      // Allow authenticated users to update memberIds and memberCount when joining/leaving
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['memberIds', 'memberCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'description', 'category', 'type', 'privacySetting', 'location', 'coverImage', 'createdByUserId', 'adminUserIds', 'createdAt']);

      // Only group creators can delete groups
      allow delete: if isGroupCreator();

      // Allow authenticated users to create groups
      allow create: if isAuthenticated() &&
        request.resource.data.createdByUserId == request.auth.uid &&
        request.resource.data.adminUserIds[0] == request.auth.uid &&
        request.resource.data.memberIds[0] == request.auth.uid;
    }
    
    // Group Memberships
    match /groupMemberships/{membershipId} {
      // Allow authenticated users to read group memberships (for leaderboards and member lists)
      // This is safe because groups are public/approval-required and membership is not private information
      // Updated to fix permission denied errors on group pages
      allow read: if request.auth != null;

      // Allow authenticated users to list memberships (for discovery and stats)
      allow list: if request.auth != null;

      // Allow users to create their own memberships (join groups)
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // Allow group admins to update memberships (approve/remove members)
      allow update: if request.auth != null &&
        exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;

      // Allow users to update their own membership status (leave group)
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.userId &&
        request.resource.data.keys().hasAll(['status']) &&
        request.resource.data.keys().hasOnly(['status', 'updatedAt']);

      // Allow group admins to delete memberships (remove members)
      allow delete: if request.auth != null &&
        exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;
    }
    
    // Challenges
    match /challenges/{challengeId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isChallengeCreator() {
        return isAuthenticated() && resource.data.createdByUserId == request.auth.uid;
      }

      function isGroupAdmin() {
        return isAuthenticated() && 
          ('groupId' in resource.data) &&
          exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
          request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;
      }

      // Allow authenticated users to read challenges
      allow read: if isAuthenticated();

      // Allow authenticated users to list challenges for discovery
      allow list: if isAuthenticated();

      // Allow group admins to create challenges for their groups
      allow create: if isAuthenticated() &&
        request.resource.data.createdByUserId == request.auth.uid &&
        (
          // Global challenge (no groupId)
          !('groupId' in request.resource.data) ||
          // Group challenge - user must be admin of the group
          (exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)) &&
           request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.adminUserIds)
        );

      // Allow challenge creators and group admins to update challenges
      allow update: if isChallengeCreator() || isGroupAdmin();

      // Allow challenge creators and group admins to delete challenges
      allow delete: if isChallengeCreator() || isGroupAdmin();

      // Allow authenticated users to update participant count when joining/leaving
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['participantCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'description', 'type', 'goalValue', 'startDate', 'endDate', 'createdByUserId', 'groupId', 'rules', 'projectIds', 'rewards', 'isActive', 'createdAt']);
    }

    // Challenge Participants
    match /challengeParticipants/{participantId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isParticipantOwner() {
        return isAuthenticated() && resource.data.userId == request.auth.uid;
      }

      function isCreatingOwnParticipation() {
        return isAuthenticated() && request.resource.data.userId == request.auth.uid;
      }

      // Allow users to read their own participation
      allow read: if isParticipantOwner();

      // Allow authenticated users to read all participants for leaderboards
      allow read: if isAuthenticated();

      // Allow authenticated users to list participants for leaderboards
      allow list: if isAuthenticated();

      // Allow users to create their own participation (join challenge)
      allow create: if isCreatingOwnParticipation();

      // Allow users to update their own participation progress
      allow update: if isParticipantOwner();

      // Allow system to update progress (for automatic progress tracking)
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['progress', 'isCompleted', 'completedAt', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['challengeId', 'userId', 'joinedAt']);

      // Allow users to delete their own participation (leave challenge)
      allow delete: if isParticipantOwner();
    }

    // Streaks
    match /streaks/{userId} {
      // Users can read/write their own streak data
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow authenticated users to read public streaks for social features (if document exists)
      allow read: if request.auth != null &&
        resource != null &&
        (resource.data.isPublic == true || !('isPublic' in resource.data));

      // Allow creating streak document if it doesn't exist (for initialization)
      allow create: if request.auth != null &&
        request.resource.data.userId == userId &&
        request.resource.data.currentStreak == 0 &&
        request.resource.data.longestStreak == 0;

      // Allow listing streaks for leaderboards (only public ones)
      allow list: if request.auth != null;
    }

    // Posts (feed posts)
    match /posts/{postId} {
      // Create: validate userId on the incoming document
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      
      // Read: allow any authenticated user to read posts
      allow read: if request.auth != null;
      
      // Update: only post owner can update their own post
      allow update: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Delete: only post owner can delete their own post
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Allow authenticated users to update supportCount and commentCount (for likes/comments)
      allow update: if request.auth != null &&
        request.resource.data.keys().hasAny(['supportCount', 'commentCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'sessionId', 'content', 'createdAt']);
    }
    
    // Post supports (likes)
    match /postSupports/{supportId} {
      allow read, write: if request.auth != null &&
        (request.auth.uid == supportId.split('_')[0] || request.auth.uid == supportId.split('_')[1]);
    }
    
    // Achievements
    match /achievements/{userId} {
      // Users can read/write their own achievements
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to read public achievements for social features
      allow read: if request.auth != null;
      
      // Allow listing achievements for leaderboards
      allow list: if request.auth != null;
    }

    // Social Graph for friendships
    match /social_graph/{userId} {
      // Allow reading the user's social graph document (if it exists)
      allow read: if request.auth != null;

      // Allow creating/updating the parent document
      allow create, update: if request.auth != null;

      // Inbound connections (followers)
      match /inbound/{friendId} {
        // Allow authenticated users to create inbound friendship records (when someone follows you)
        allow create: if request.auth != null;

        // Allow any authenticated user to read inbound friendships (followers)
        allow read: if request.auth != null;

        // Allow listing all inbound connections
        allow list: if request.auth != null;

        // Allow authenticated users to delete inbound friendship records (when someone unfollows you)
        allow delete: if request.auth != null;

        // Allow the user to manage their own inbound records
        allow update: if request.auth != null && request.auth.uid == userId;
      }

      // Outbound connections (following)
      match /outbound/{friendId} {
        // Users can manage their own outbound friendships (following)
        allow read, create, update, delete: if request.auth != null && request.auth.uid == userId;

        // Allow any authenticated user to read outbound friendships (for discovery)
        allow read: if request.auth != null;

        // Allow listing all outbound connections
        allow list: if request.auth != null;
      }
    }

    // (users match consolidated above)
  }
}
