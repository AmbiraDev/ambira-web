rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection and activeSession subcollection
    match /users/{userId} {
      // Owner can read/write own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow any authenticated user to update follower/following counts
      // This is safe because only increment/decrement operations are used in the code
      allow update: if request.auth != null && 
        request.resource.data.keys().hasAny(['followersCount', 'followingCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'username', 'name', 'bio', 'location', 'profilePicture', 'totalHours', 'profileVisibility', 'activityVisibility', 'projectVisibility', 'createdAt']);

      // Allow authenticated users to read user profiles based on visibility settings
      allow read: if request.auth != null &&
        (resource.data.profileVisibility == 'everyone' ||
         !('profileVisibility' in resource.data));
      
      // Allow followers to read profiles with 'followers' visibility
      allow read: if request.auth != null &&
        resource.data.profileVisibility == 'followers' &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));

      // Allow listing users for discovery when authenticated
      allow list: if request.auth != null;

      // Active session subcollection - user can read/write their own active timer
      match /activeSession/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // User activities
    match /activities/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read activities if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'followers' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'everyone' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // User activities subcollections (daily, weekly, etc.)
    match /activities/{userId}/{subcollection} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read activities if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'followers' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.activityVisibility == 'everyone' ||
         !('activityVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // User projects - using subcollection structure
    match /projects/{userId}/userProjects/{projectId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read projects if visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'followers' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'everyone' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // User project tasks - subcollection of projects
    match /projects/{userId}/userProjects/{projectId}/tasks/{taskId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Allow followers to read tasks if project visibility allows (with fallback)
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'followers' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data)) &&
        exists(/databases/$(database)/documents/follows/$(request.auth.uid + '_' + userId));
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.projectVisibility == 'everyone' ||
         !('projectVisibility' in get(/databases/$(database)/documents/users/$(userId)).data));
    }
    
    // Sessions
    match /sessions/{sessionId} {
      // Create: validate userId on the incoming document
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      // Read/Update/Delete: validate against stored document
      allow read, update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
      // Allow reading sessions for stats calculation (authenticated users can read any session)
      allow read: if request.auth != null;
      // Allow authenticated users to update supportCount and commentCount (for likes/comments)
      allow update: if request.auth != null &&
        request.resource.data.keys().hasAny(['supportCount', 'commentCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'projectId', 'title', 'description', 'duration', 'startTime', 'tasks', 'tags', 'visibility', 'createdAt']);
    }
    
    // Session supports (likes/kudos)
    match /sessionSupports/{supportId} {
      allow read, write: if request.auth != null &&
        (request.auth.uid == supportId.split('_')[0] || request.auth.uid == supportId.split('_')[1]);
    }
    
    // Comments
    match /comments/{commentId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      // Create: validate userId on the incoming document
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;

      // Read/list: allow any authenticated user to fetch comments (per-document rules apply)
      allow get: if isAuthenticated();
      allow list: if isAuthenticated();

      // Update: only comment owner can modify their own comment
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // Delete: only comment owner can delete their own comment
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Comment likes
    match /commentLikes/{likeId} {
      allow read, write: if request.auth != null && 
        (request.auth.uid == likeId.split('_')[0] || request.auth.uid == likeId.split('_')[1]);
    }
    
    // Notifications
    match /notifications/{notificationId} {
      // Create: validate userId on the incoming document (for system-created notifications)
      allow create: if request.auth != null;
      // Read/Update/Delete: only notification owner can access
      allow read, update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Unassigned tasks (user's personal tasks)
    match /users/{userId}/tasks/{taskId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Follows
    match /follows/{followId} {
      // Create: validate followerId matches authenticated user and both users exist
      allow create: if request.auth != null && 
        request.resource.data.followerId == request.auth.uid &&
        request.resource.data.followingId != request.auth.uid &&
        exists(/databases/$(database)/documents/users/$(request.resource.data.followingId));
      
      // Read: allow authenticated users to read follows for stats calculation
      allow read: if request.auth != null;
      
      // Delete: only the follower can delete their own follow
      allow delete: if request.auth != null && resource.data.followerId == request.auth.uid;
    }
    
    // Groups
    match /groups/{groupId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isDiscoverablePrivacy(setting) {
        return setting == 'public' || setting == 'approval-required';
      }

      function isDiscoverableGroup() {
        return ('privacySetting' in resource.data &&
          isDiscoverablePrivacy(resource.data.privacySetting)) ||
          !('privacySetting' in resource.data);
      }

      function isGroupMember() {
        return isAuthenticated() &&
          ('memberIds' in resource.data) &&
          resource.data.memberIds.hasAny([request.auth.uid]);
      }

      function isGroupAdmin() {
        return isAuthenticated() &&
          ('adminUserIds' in resource.data) &&
          resource.data.adminUserIds.hasAny([request.auth.uid]);
      }

      function isGroupCreator() {
        return isAuthenticated() &&
          resource.data.createdByUserId == request.auth.uid;
      }

      // Allow reading individual groups for public or approval-required access, or members
      allow get: if isDiscoverableGroup() || isGroupMember();

      // Allow listing groups for authenticated discovery experiences
      allow list: if isAuthenticated();

      // Allow group creators and admins to update group
      allow update: if isGroupCreator() || isGroupAdmin();

      // Allow authenticated users to update memberIds and memberCount when joining/leaving
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['memberIds', 'memberCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'description', 'category', 'type', 'privacySetting', 'location', 'coverImage', 'createdByUserId', 'adminUserIds', 'createdAt']);

      // Only group creators can delete groups
      allow delete: if isGroupCreator();

      // Allow authenticated users to create groups
      allow create: if isAuthenticated() &&
        request.resource.data.createdByUserId == request.auth.uid &&
        request.resource.data.adminUserIds[0] == request.auth.uid &&
        request.resource.data.memberIds[0] == request.auth.uid;
    }
    
    // Group Memberships
    match /groupMemberships/{membershipId} {
      // Allow users to read their own memberships
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Allow group members to read other memberships for the same group
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.memberIds;
      
      // Allow users to create their own memberships (join groups)
      allow create: if request.auth != null && 
        request.resource.data.userId == request.auth.uid;
      
      // Allow group admins to update memberships (approve/remove members)
      allow update: if request.auth != null && 
        exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;
      
      // Allow users to update their own membership status (leave group)
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId &&
        request.resource.data.keys().hasAll(['status']) &&
        request.resource.data.keys().hasOnly(['status', 'updatedAt']);
      
      // Allow group admins to delete memberships (remove members)
      allow delete: if request.auth != null && 
        exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
        request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;
    }
    
    // Challenges
    match /challenges/{challengeId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isChallengeCreator() {
        return isAuthenticated() && resource.data.createdByUserId == request.auth.uid;
      }

      function isGroupAdmin() {
        return isAuthenticated() && 
          ('groupId' in resource.data) &&
          exists(/databases/$(database)/documents/groups/$(resource.data.groupId)) &&
          request.auth.uid in get(/databases/$(database)/documents/groups/$(resource.data.groupId)).data.adminUserIds;
      }

      // Allow authenticated users to read challenges
      allow read: if isAuthenticated();

      // Allow authenticated users to list challenges for discovery
      allow list: if isAuthenticated();

      // Allow group admins to create challenges for their groups
      allow create: if isAuthenticated() &&
        request.resource.data.createdByUserId == request.auth.uid &&
        (
          // Global challenge (no groupId)
          !('groupId' in request.resource.data) ||
          // Group challenge - user must be admin of the group
          (exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)) &&
           request.auth.uid in get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)).data.adminUserIds)
        );

      // Allow challenge creators and group admins to update challenges
      allow update: if isChallengeCreator() || isGroupAdmin();

      // Allow challenge creators and group admins to delete challenges
      allow delete: if isChallengeCreator() || isGroupAdmin();

      // Allow authenticated users to update participant count when joining/leaving
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['participantCount', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'description', 'type', 'goalValue', 'startDate', 'endDate', 'createdByUserId', 'groupId', 'rules', 'projectIds', 'rewards', 'isActive', 'createdAt']);
    }

    // Challenge Participants
    match /challengeParticipants/{participantId} {
      function isAuthenticated() {
        return request.auth != null;
      }

      function isParticipantOwner() {
        return isAuthenticated() && resource.data.userId == request.auth.uid;
      }

      function isCreatingOwnParticipation() {
        return isAuthenticated() && request.resource.data.userId == request.auth.uid;
      }

      // Allow users to read their own participation
      allow read: if isParticipantOwner();

      // Allow authenticated users to read all participants for leaderboards
      allow read: if isAuthenticated();

      // Allow authenticated users to list participants for leaderboards
      allow list: if isAuthenticated();

      // Allow users to create their own participation (join challenge)
      allow create: if isCreatingOwnParticipation();

      // Allow users to update their own participation progress
      allow update: if isParticipantOwner();

      // Allow system to update progress (for automatic progress tracking)
      allow update: if isAuthenticated() &&
        request.resource.data.keys().hasAny(['progress', 'isCompleted', 'completedAt', 'updatedAt']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['challengeId', 'userId', 'joinedAt']);

      // Allow users to delete their own participation (leave challenge)
      allow delete: if isParticipantOwner();
    }

    // (users match consolidated above)
  }
}
