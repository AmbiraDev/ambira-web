{
  "Feature Query Hook": {
    "prefix": "rq-query",
    "description": "Create a feature query hook following the standardized pattern",
    "body": [
      "import { useQuery } from '@tanstack/react-query';",
      "import { ${1:Feature}Service } from '../services/${1:Feature}Service';",
      "import type { QueryOptions } from '@/lib/react-query';",
      "import { STANDARD_CACHE_TIMES } from '@/lib/react-query';",
      "",
      "const ${2:featureName}Service = new ${1:Feature}Service();",
      "",
      "/**",
      " * Get ${3:description}",
      " *",
      " * @example",
      " * const { data, isLoading, error } = use${4:HookName}(${5:param});",
      " */",
      "export function use${4:HookName}(",
      "  ${5:param}: ${6:ParamType},",
      "  options?: QueryOptions<${7:ReturnType}>",
      ") {",
      "  return useQuery<${7:ReturnType}, Error>({",
      "    queryKey: ${8:FEATURE}_KEYS.${9:keyName}(${5:param}),",
      "    queryFn: () => ${2:featureName}Service.${10:methodName}(${5:param}),",
      "    staleTime: STANDARD_CACHE_TIMES.${11|LONG,MEDIUM,SHORT,VERY_LONG|},",
      "    enabled: !!${5:param},",
      "    ...options,",
      "  });",
      "}",
      ""
    ]
  },

  "Feature Mutation Hook": {
    "prefix": "rq-mutation",
    "description": "Create a feature mutation hook with optimistic updates",
    "body": [
      "import { useMutation, useQueryClient } from '@tanstack/react-query';",
      "import { ${1:Feature}Service } from '../services/${1:Feature}Service';",
      "import type { MutationOptions } from '@/lib/react-query';",
      "import { ${2:FEATURE}_KEYS } from './use${1:Feature}';",
      "",
      "const ${3:featureName}Service = new ${1:Feature}Service();",
      "",
      "/**",
      " * ${4:Mutation description}",
      " *",
      " * @example",
      " * const mutation = use${5:MutationName}();",
      " * mutation.mutate({ ${6:param}: '${7:value}' });",
      " */",
      "export function use${5:MutationName}(",
      "  options?: MutationOptions<${8:ReturnType}, ${9:VariablesType}>",
      ") {",
      "  const queryClient = useQueryClient();",
      "",
      "  return useMutation<${8:ReturnType}, Error, ${9:VariablesType}>({",
      "    mutationFn: (variables) => ${3:featureName}Service.${10:methodName}(variables),",
      "",
      "    onMutate: async (variables) => {",
      "      // Cancel outgoing queries",
      "      await queryClient.cancelQueries({ queryKey: ${2:FEATURE}_KEYS.${11:keyName}(variables.${12:id}) });",
      "",
      "      // Snapshot previous value",
      "      const previousData = queryClient.getQueryData(${2:FEATURE}_KEYS.${11:keyName}(variables.${12:id}));",
      "",
      "      // Optimistically update",
      "      queryClient.setQueryData(${2:FEATURE}_KEYS.${11:keyName}(variables.${12:id}), (old: any) => {",
      "        if (!old) return old;",
      "        return {",
      "          ...old,",
      "          // Update logic here",
      "        };",
      "      });",
      "",
      "      return { previousData };",
      "    },",
      "",
      "    onError: (error, variables, context) => {",
      "      // Rollback on error",
      "      if (context?.previousData) {",
      "        queryClient.setQueryData(${2:FEATURE}_KEYS.${11:keyName}(variables.${12:id}), context.previousData);",
      "      }",
      "    },",
      "",
      "    onSuccess: (data, variables) => {",
      "      // Invalidate relevant caches",
      "      queryClient.invalidateQueries({ queryKey: ${2:FEATURE}_KEYS.${11:keyName}(variables.${12:id}) });",
      "    },",
      "",
      "    ...options,",
      "  });",
      "}",
      ""
    ]
  },

  "Feature Cache Keys": {
    "prefix": "rq-keys",
    "description": "Create hierarchical cache keys for a feature",
    "body": [
      "/**",
      " * Cache keys for ${1:Feature}",
      " *",
      " * Hierarchical structure allows efficient invalidation:",
      " * - ${2:FEATURE}_KEYS.all() invalidates everything",
      " * - ${2:FEATURE}_KEYS.lists() invalidates all lists",
      " * - ${2:FEATURE}_KEYS.detail(id) invalidates one item",
      " */",
      "export const ${2:FEATURE}_KEYS = {",
      "  all: () => ['${3:feature}'] as const,",
      "  lists: () => [...${2:FEATURE}_KEYS.all(), 'list'] as const,",
      "  list: (filters?: string) => [...${2:FEATURE}_KEYS.lists(), { filters }] as const,",
      "  details: () => [...${2:FEATURE}_KEYS.all(), 'detail'] as const,",
      "  detail: (id: string) => [...${2:FEATURE}_KEYS.details(), id] as const,",
      "  ${4:customKey}: (${5:param}: ${6:type}) => [...${2:FEATURE}_KEYS.all(), '${4:customKey}', ${5:param}] as const,",
      "};",
      ""
    ]
  },

  "Feature Service": {
    "prefix": "rq-service",
    "description": "Create a feature service with repository",
    "body": [
      "/**",
      " * ${1:Feature} Service - Business Logic Layer",
      " *",
      " * Orchestrates business workflows for ${2:feature}.",
      " * No React dependencies - pure TypeScript for testability.",
      " */",
      "",
      "import { ${3:Repository} } from '@/infrastructure/firebase/repositories/${3:Repository}';",
      "import { ${4:Entity} } from '@/domain/entities/${4:Entity}';",
      "",
      "export class ${1:Feature}Service {",
      "  private readonly ${5:repo}: ${3:Repository};",
      "",
      "  constructor() {",
      "    this.${5:repo} = new ${3:Repository}();",
      "  }",
      "",
      "  /**",
      "   * ${6:Method description}",
      "   */",
      "  async ${7:methodName}(${8:params}: ${9:ParamsType}): Promise<${10:ReturnType}> {",
      "    // Business logic here",
      "    return this.${5:repo}.${11:repoMethod}(${8:params});",
      "  }",
      "",
      "  /**",
      "   * ${12:Another method description}",
      "   */",
      "  async ${13:anotherMethod}(${14:params}: ${15:ParamsType}): Promise<${16:ReturnType}> {",
      "    // Business logic with validation",
      "    ${17:// Add business rules here}",
      "",
      "    return this.${5:repo}.${18:repoMethod}(${14:params});",
      "  }",
      "}",
      ""
    ]
  },

  "Feature Hooks Index": {
    "prefix": "rq-hooks-index",
    "description": "Create hooks index file for clean exports",
    "body": [
      "/**",
      " * ${1:Feature} Hooks - Public API",
      " *",
      " * All ${2:feature}-related hooks exported from here.",
      " *",
      " * @example",
      " * import { use${3:Query}, use${4:Mutation} } from '@/features/${2:feature}/hooks';",
      " */",
      "",
      "// Query hooks",
      "export {",
      "  use${3:Query},",
      "  ${5:// Add more query hooks}",
      "  ${6:FEATURE}_KEYS,",
      "} from './use${1:Feature}';",
      "",
      "// Mutation hooks",
      "export {",
      "  use${4:Mutation},",
      "  ${7:// Add more mutation hooks}",
      "  useInvalidate${1:Feature},",
      "} from './use${1:Feature}Mutations';",
      ""
    ]
  },

  "Infinite Query Hook": {
    "prefix": "rq-infinite",
    "description": "Create an infinite query hook for pagination",
    "body": [
      "import { useInfiniteQuery } from '@tanstack/react-query';",
      "import { ${1:Feature}Service } from '../services/${1:Feature}Service';",
      "import type { QueryOptions } from '@/lib/react-query';",
      "",
      "const ${2:featureName}Service = new ${1:Feature}Service();",
      "",
      "/**",
      " * Get paginated ${3:description}",
      " *",
      " * @example",
      " * const { data, fetchNextPage, hasNextPage } = use${4:HookName}(${5:param});",
      " */",
      "export function use${4:HookName}(",
      "  ${5:param}: ${6:ParamType},",
      "  options?: QueryOptions<${7:ReturnType}>",
      ") {",
      "  return useInfiniteQuery({",
      "    queryKey: ${8:FEATURE}_KEYS.${9:keyName}(${5:param}),",
      "    queryFn: ({ pageParam }) =>",
      "      ${2:featureName}Service.${10:methodName}(${5:param}, {",
      "        limit: 20,",
      "        cursor: pageParam,",
      "      }),",
      "    getNextPageParam: (lastPage) =>",
      "      lastPage.hasMore ? lastPage.nextCursor : undefined,",
      "    initialPageParam: undefined as string | undefined,",
      "    staleTime: 1 * 60 * 1000, // 1 minute",
      "    enabled: !!${5:param},",
      "    ...options,",
      "  });",
      "}",
      ""
    ]
  },

  "Component with Feature Hooks": {
    "prefix": "rq-component",
    "description": "Create a component using feature hooks",
    "body": [
      "'use client';",
      "",
      "import { use${1:Query}, use${2:Mutation} } from '@/features/${3:feature}/hooks';",
      "",
      "export default function ${4:Component}({ ${5:param} }: { ${5:param}: ${6:Type} }) {",
      "  // Query hooks",
      "  const { data, isLoading, error } = use${1:Query}(${5:param});",
      "",
      "  // Mutation hooks",
      "  const mutation = use${2:Mutation}();",
      "",
      "  // Event handlers",
      "  const handle${7:Action} = () => {",
      "    mutation.mutate({ ${8:variables} });",
      "  };",
      "",
      "  // Loading state",
      "  if (isLoading) {",
      "    return <div>Loading...</div>;",
      "  }",
      "",
      "  // Error state",
      "  if (error) {",
      "    return <div>Error: {error.message}</div>;",
      "  }",
      "",
      "  // Empty state",
      "  if (!data) {",
      "    return <div>No data found</div>;",
      "  }",
      "",
      "  // Main render",
      "  return (",
      "    <div>",
      "      <h1>${9:Title}</h1>",
      "      <button",
      "        onClick={handle${7:Action}}",
      "        disabled={mutation.isPending}",
      "      >",
      "        {mutation.isPending ? 'Loading...' : '${10:Action}'}",
      "      </button>",
      "    </div>",
      "  );",
      "}",
      ""
    ]
  }
}
